import abc
from typing import Optional, List, Callable

from aoe_rms_spoon.exceptions import RMSSemanticErrorException
from aoe_rms_spoon.models import SemanticCheckOutput, CodeGenerationOutput


class IRMSStatement(abc.ABC):
    """
    A generic RMS statement
    """

    def __init__(self):
        self.parent = None

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        return self.parent

    def get_aoe_version(self) -> "AbstractAoeVersion":
        return self.get_parent().get_aoe_version()

    @abc.abstractmethod
    def semantic_validate(self, semantic_input: "SemanticCheckInput") -> "Optional[SemanticCheckOutput]":
        """
        Perform semantic check of the language
        :param semantic_input: input to the semantic routine of this AST
        :return: semantic check output. If None we will assume the check was correct.
        The semantic input will be forwarded as well
        """
        pass

    @abc.abstractmethod
    def code_generation(self, context: "CodeGenerationInput") -> "CodeGenerationOutput":
        """
        Convert the statement into an RMS statement that can be put into the file.
        If you want to call the generate of the children of the method, call default_code_generation
        :return:
        """
        pass

    def default_semantic_validate(self, semantic_input: "SemanticCheckInput") -> "Optional[SemanticCheckOutput]":
        """
        A semantic check that simply return tru only if all the children are semantically correct
        :param semantic_input: input to the semantic routine of this AST
        :return:
        """
        for i, stmt in enumerate(self.get_children()):
            output = stmt.semantic_validate(semantic_input)
            if output is not None and output.is_error():
                return SemanticCheckOutput.error(semantic_input, output.exception)
        return SemanticCheckOutput.ok(semantic_input)

    def default_code_generation(self, context: "CodeGenerationInput") -> "CodeGenerationOutput":
        """
        Simply call generate of the children of this statement
        :return: string generated by this statement
        """
        result = []
        for i, stmt in enumerate(self.get_children()):
            output = stmt.code_generation(context)
            result.extend(output.rms)
            if output.newline:
                result.append("")
        return CodeGenerationOutput(result, True, context)

    @abc.abstractmethod
    def is_section_declaration(self) -> bool:
        """
        true if this statement represents a RMS section declaration (e.g., OBJECT_GENERATION)
        :return:
        """
        pass

    def is_leaf(self) -> bool:
        """

        :return: true if this statement has no rms statement under it
        """
        return len(self.get_children()) == 0

    def is_root(self) -> bool:
        """

        :return: True if this node is the root of the RMS statement file
        """
        return self.get_parent() is None

    @abc.abstractmethod
    def get_name(self) -> str:
        """
        Human readable bname of the node
        :return:
        """
        pass

    @abc.abstractmethod
    def get_children(self) -> List["IRMSStatement"]:
        """
        the children of this rms
        :return:
        """
        pass

    def get_parent(self) -> Optional["INonTerminalRMSStatement"]:
        """
        parent of this rms statement
        :return: none if this is the AST tree
        """
        return self.parent

    def set_parent(self, new_parent: "INonTerminalRMSStatement"):
        self.parent = new_parent

    def get_path(self) -> str:
        """
        Generate a string that uniquely identifies this node
        :return:
        """

        path = []
        tmp = self
        while True:
            path.append(tmp)
            if tmp.is_root():
                break
            tmp = tmp.get_parent()

        # we have the rms stmt path from the bottom till the top. To generate the string, we now have to reverse it
        path = reversed(path)

        result = []
        for i, item in enumerate(path):
            result.append(" " * (2*i) + "- " + item.get_name())
        return '\n'.join(result)

    def add_statement(self, stmt: "IRMSStatement") -> "IRMSStatement":
        stmt.set_parent(new_parent=self)
        self.get_children().append(stmt)
        return self

    def add_or_replace_child(self, index: int, stmt: "IRMSStatement") -> "IRMSStatement":
        """
        Adds a child to this statement. If the index is greater than the current children number, it adds it to the list
        of childre. Othewise we overwrite the previous children (and its whoole subtree)
        :param index:
        :param stmt:
        :return:
        """
        if index >= len(self.get_children()):
            self.add_statement(stmt)
        else:
            stmt.set_parent(new_parent=self)
            self.get_children()[index] = stmt
        return self

    def is_there_direct_child_st(self, filter_clause: Callable[[int, "IRMSStatement"], bool]) -> bool:
        """
        Check if there is a child that satisfies the function
        :param filter_clause: filter to satisfy
        :return: node requested or None if no siblign satisfy the condition
        """
        return self.find_direct_child_st(filter_clause) is not None

    def find_direct_child_st(self, filter_clause: Callable[[int, "IRMSStatement"], bool]) -> Optional["IRMSStatement"]:
        """
        Get the first child that satisfies the function
        :param filter_clause: filter to satisfy
        :return: node requested or None if no siblign satisfy the condition
        """
        if self.is_leaf():
            return None

        for i, child in enumerate(self.get_children()):
            if filter_clause(i, child):
                return child
        else:
            return None

    def is_there_sibling_st(self, filter_clause: Callable[[int, "IRMSStatement"], bool]) -> bool:
        """
        Check if there is a sibling that satisfies the function. The given node won't be considered as sibling of itself
        :param filter_clause: filter to satisfy
        :return: true if threre is a node requested or None if no siblign satisfy the condition
        """
        return self.find_sibling_st(filter_clause) is not None

    def find_sibling_st(self, filter_clause: Callable[[int, "IRMSStatement"], bool]) -> Optional["IRMSStatement"]:
        """
        Get the first sibling that satisfies the function. The given node won't be considered as sibling of itself
        :param filter_clause: filter to satisfy
        :return: node requested or None if no siblign satisfy the condition
        """
        if self.is_root():
            return None

        for i, sibling in self.get_parent().get_children():
            if sibling == self:
                continue
            if filter_clause(i, sibling):
                return sibling
        else:
            return None

    def has_direct_child_of_type(self, t: type) -> bool:
        """
        :param t:
        :return: True if the node has a child of the given type
        """

        def check(index: int, child: "IRMSStatement") -> bool:
            return isinstance(child, t)

        return self.is_there_direct_child_st(check)

    def has_sibling_of_type(self, t: type) -> bool:
        """
        :param t:
        :return: True if the node has a siblign of the given type
        """

        def check(index: int, sibling: "IRMSStatement") -> bool:
            return isinstance(sibling, t)

        return self.is_there_sibling_st(check)

    def has_sibling_among_types(self, *types) -> bool:
        """
        :param types: the types you want to scan
        :return: True if the node has a siblign among the given types
        """

        def check(index: int, sibling: "IRMSStatement") -> bool:
            for t in types:
                if isinstance(sibling, t):
                    return True
            else:
                return False

        return self.is_there_sibling_st(check)

    def has_direct_child_different_than_types(self, *types) -> bool:
        """
        :param types: the types you want to scan
        :return: True if the node has a child different from the types specified
        """

        def check(index: int, child: "IRMSStatement") -> bool:
            for t in types:
                if not isinstance(child, t):
                    return True
            else:
                return False

        return self.is_there_direct_child_st(check)

    def has_direct_child_different_than_typenames(self, *types) -> bool:
        """
           :param types: name of the types you want to scan
           :return: True if the node has a child different from the types specified
           """

        def check(index: int, child: "IRMSStatement") -> bool:
            for t in types:
                if type(child).__name__ == t:
                    return True
            else:
                return False

        return self.is_there_direct_child_st(check)

    def has_ith_child_has_type(self, index: int, t: type) -> bool:
        def check(aindex: int, achild: "IRMSStatement") -> bool:
            if index != aindex:
                # different children are ignored
                return False
            # we assume it is an expression
            if not isinstance(achild, Expression):
                raise TypeError(f"Expected expression, but got {type(achild)}")

            if t == int and achild.is_int():
                return True
            if t == bool and achild.is_boolean():
                return True
            if t == float and achild.is_float():
                return True
            return False

        return self.is_there_direct_child_st(check)

    def ensure_ith_child_has_type(self, index: int, t: type):
        if not self.has_ith_child_has_type(index, t):
            raise RMSSemanticErrorException(f"Unexpected {index}-th child!  Expected type {t}")

    def has_parent_is_of_type(self, t: type) -> bool:
        if self.is_root():
            return False
        return isinstance(self.get_parent(), t)

    def ensure_parent_is_of_type(self, t: type):
        """
        Make sure that the parent of this node exists and is of the specifi type
        :param t: type the parent needs to have
        :raise: exception if the check fails
        """
        if not self.has_parent_is_of_type(t):
            raise RMSSemanticErrorException(f"Parent of {self} should be {t}, but instead it was Unexpected {type(self.parent)}!")